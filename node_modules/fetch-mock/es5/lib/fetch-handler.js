'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ResponseBuilder = require('./response-builder');
var requestUtils = require('./request-utils');
var FetchMock = {};

var normalizeRequest = function normalizeRequest(url, options, Request) {
	if (Request.prototype.isPrototypeOf(url)) {
		var obj = {
			url: requestUtils.normalizeUrl(url.url),
			opts: {
				method: url.method
			},
			request: url
		};

		var headers = requestUtils.headers.toArray(url.headers);

		if (headers.length) {
			obj.opts.headers = requestUtils.headers.zip(headers);
		}
		return obj;
	} else if (typeof url === 'string' ||
	// horrible URL object duck-typing
	(typeof url === 'undefined' ? 'undefined' : (0, _typeof3.default)(url)) === 'object' && 'href' in url) {
		return {
			url: requestUtils.normalizeUrl(url),
			opts: options
		};
	} else if ((typeof url === 'undefined' ? 'undefined' : (0, _typeof3.default)(url)) === 'object') {
		throw new TypeError('fetch-mock: Unrecognised Request object. Read the Config and Installation sections of the docs');
	} else {
		throw new TypeError('fetch-mock: Invalid arguments passed to fetch');
	}
};

FetchMock.fetchHandler = function (url, opts, request) {
	var _this = this;

	var _normalizeRequest = normalizeRequest(url, opts, this.config.Request);

	url = _normalizeRequest.url;
	opts = _normalizeRequest.opts;
	request = _normalizeRequest.request;


	var route = this.executeRouter(url, opts, request);

	// this is used to power the .flush() method
	var done = void 0;
	this._holdingPromises.push(new this.config.Promise(function (res) {
		return done = res;
	}));

	// wrapped in this promise to make sure we respect custom Promise
	// constructors defined by the user
	return new this.config.Promise(function (res, rej) {
		_this.generateResponse(route, url, opts).then(res, rej).then(done, done);
	});
};

FetchMock.fetchHandler.isMock = true;

FetchMock.executeRouter = function (url, options, request) {
	if (this.config.fallbackToNetwork === 'always') {
		return { response: this.getNativeFetch() };
	}

	var match = this.router(url, options, request);

	if (match) {
		return match;
	}

	if (this.config.warnOnFallback) {
		console.warn('Unmatched ' + (options && options.method || 'GET') + ' to ' + url); // eslint-disable-line
	}

	this.push(null, { url: url, options: options, request: request });

	if (this.fallbackResponse) {
		return { response: this.fallbackResponse };
	}

	if (!this.config.fallbackToNetwork) {
		throw new Error('fetch-mock: No fallback response defined for ' + (options && options.method || 'GET') + ' to ' + url);
	}

	return { response: this.getNativeFetch() };
};

FetchMock.generateResponse = function () {
	var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(route, url, opts) {
		var response;
		return _regenerator2.default.wrap(function _callee$(_context) {
			while (1) {
				switch (_context.prev = _context.next) {
					case 0:
						// We want to allow things like
						// - function returning a Promise for a response
						// - delaying (using a timeout Promise) a function's execution to generate
						//   a response
						// Because of this we can't safely check for function before Promisey-ness,
						// or vice versa. So to keep it DRY, and flexible, we keep trying until we
						// have something that looks like neither Promise nor function
						response = route.response;

					case 1:
						if (!(typeof response === 'function' || typeof response.then === 'function')) {
							_context.next = 11;
							break;
						}

						if (!(typeof response === 'function')) {
							_context.next = 6;
							break;
						}

						response = response(url, opts);
						_context.next = 9;
						break;

					case 6:
						_context.next = 8;
						return response.then(function (it) {
							return it;
						});

					case 8:
						response = _context.sent;

					case 9:
						_context.next = 1;
						break;

					case 11:
						if (!(response.throws && typeof response !== 'function')) {
							_context.next = 13;
							break;
						}

						throw response.throws;

					case 13:
						if (!this.config.Response.prototype.isPrototypeOf(response)) {
							_context.next = 15;
							break;
						}

						return _context.abrupt('return', response);

					case 15:
						return _context.abrupt('return', new ResponseBuilder({
							url: url,
							shorthandResponse: response,
							fetchMock: this,
							route: route
						}).exec());

					case 16:
					case 'end':
						return _context.stop();
				}
			}
		}, _callee, this);
	}));

	return function (_x, _x2, _x3) {
		return _ref.apply(this, arguments);
	};
}();

FetchMock.router = function (url, options, request) {
	var route = this.routes.find(function (route) {
		return route.matcher(url, options, request);
	});

	if (route) {
		this.push(route.name, { url: url, options: options, request: request });
		return route;
	}
};

FetchMock.getNativeFetch = function () {
	var func = this.realFetch || this.isSandbox && this.config.fetch;
	if (!func) {
		throw new Error('fetch-mock: Falling back to network only available on gloabl fetch-mock, or by setting config.fetch on sandboxed fetch-mock');
	}
	return func;
};

FetchMock.push = function (name, _ref2) {
	var url = _ref2.url,
	    options = _ref2.options,
	    request = _ref2.request;

	var args = [url, options];
	args.request = request;
	if (name) {
		this._calls[name] = this._calls[name] || [];
		this._calls[name].push(args);
		this._allCalls.push(args);
	} else {
		args.unmatched = true;
		this._allCalls.push(args);
	}
};

module.exports = FetchMock;