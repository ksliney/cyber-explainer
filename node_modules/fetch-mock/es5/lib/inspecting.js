'use strict';

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _require = require('./request-utils'),
    normalizeUrl = _require.normalizeUrl;

var FetchMock = {};
var compileRoute = require('./compile-route');

FetchMock.filterCallsByName = function (name) {
	if (name === true) {
		return this._allCalls.filter(function (call) {
			return !call.unmatched;
		});
	}
	if (name === false) {
		return this._allCalls.filter(function (call) {
			return call.unmatched;
		});
	}

	if (typeof name === 'undefined') {
		return this._allCalls;
	}

	if (this.routes.some(function (route) {
		return route.name === name;
	})) {
		return this._calls[name] || [];
	}
};

FetchMock.filterCallsWithRoute = function (name) {
	var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	var matcher = compileRoute((0, _assign2.default)({ matcher: name, response: 'ok' }, options)).matcher;
	return this._allCalls.filter(function (_ref) {
		var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
		    url = _ref2[0],
		    opts = _ref2[1];

		return (
			// HACK: add dummy response so that we can generate a matcher without
			// copileRoute's expectation that each route has a response defined
			matcher(normalizeUrl(url), opts)
		);
	});
};

FetchMock.filterCalls = function (name, options) {
	var calls = void 0;
	if (options) {
		if (typeof options === 'string') {
			options = { method: options };
		}
		calls = this.filterCallsWithRoute(name, options);
	} else {
		calls = this.filterCallsByName(name);
		if (!calls) {
			calls = this.filterCallsWithRoute(name);
		}
	}

	return calls;
};

FetchMock.calls = function (name, options) {
	return this.filterCalls(name, options);
};

FetchMock.lastCall = function (name, options) {
	return [].concat((0, _toConsumableArray3.default)(this.filterCalls(name, options))).pop();
};

FetchMock.lastUrl = function (name, options) {
	return (this.lastCall(name, options) || [])[0];
};

FetchMock.lastOptions = function (name, options) {
	return (this.lastCall(name, options) || [])[1];
};

FetchMock.called = function (name, options) {
	return !!this.filterCalls(name, options).length;
};

FetchMock.flush = function (waitForResponseMethods) {
	var _this = this;

	var queuedPromises = this._holdingPromises;
	this._holdingPromises = [];

	return _promise2.default.all(queuedPromises).then(function () {
		if (waitForResponseMethods && _this._holdingPromises.length) {
			return _this.flush(waitForResponseMethods);
		}
	});
};

FetchMock.done = function (name, options) {
	var _this2 = this;

	var names = name && typeof name !== 'boolean' ? [{ name: name }] : this.routes;

	// Can't use array.every because
	// a) not widely supported
	// b) would exit after first failure, which would break the logging
	return names.map(function (_ref3) {
		var name = _ref3.name,
		    method = _ref3.method;

		// HACK - this is horrible. When the api is eventually updated to update other
		// filters other than a method string it will break... but for now it's ok-ish
		method = options || method;

		if (!_this2.called(name, method)) {
			console.warn('Warning: ' + name + ' not called'); // eslint-disable-line
			return false;
		}

		// would use array.find... but again not so widely supported
		var expectedTimes = (_this2.routes.filter(function (r) {
			return r.name === name && r.method === method;
		}) || [{}])[0].repeat;
		if (!expectedTimes) {
			return true;
		}

		var actualTimes = _this2.filterCalls(name, method).length;
		if (expectedTimes > actualTimes) {
			console.warn('Warning: ' + name + ' only called ' + actualTimes + ' times, but ' + expectedTimes + ' expected'); // eslint-disable-line
			return false;
		} else {
			return true;
		}
	}).filter(function (bool) {
		return !bool;
	}).length === 0;
};

module.exports = FetchMock;